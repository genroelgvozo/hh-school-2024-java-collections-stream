package tasks;

import common.ApiPersonDto;
import common.Person;
import common.PersonConverter;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/*
Задача 4
Список персон класса Person необходимо сконвертировать в список ApiPersonDto
(предположим, что это некоторый внешний формат)
Конвертер для одной персоны - personConverter.convert()
FYI - DTO = Data Transfer Object - распространенный паттерн, можно погуглить
 */
public class Task4 {

  private final PersonConverter personConverter;

  public Task4(PersonConverter personConverter) {
    this.personConverter = personConverter;
  }

  public List<ApiPersonDto> convert(List<Person> persons) {
    return persons.stream() // если список персон очень большой параллельный стрим может ускорить процесс конвертации, но можно, конечно обычным стримом
        .map(personConverter::convert)
        .collect(Collectors.toList());
  }
  /*
     Вообще параллельный стрим обычно используют в случае если нужно для огромного количества данных произвести на них интенсивные вычислительные операции.
     Тогда можно с помощью параллельности разбить процесс на несколько потоков чтобы они выполнялись на отдельных ядрах
     Однако тут такого не происходит, я просто хотела протестировать будет ли работать новая для меня функцич да и все...
     Тут даже скорее лучше его не использовать:
     Параллельные стримы разбивают исходный набор данных на части, которые можно обрабатывать одновременно. Это может ускорить выполнение при достаточном объеме данных. Но!
     Создание и управление несколькими потоками имеет свои накладные расходы
     (например: при работе с небольшими наборами данных и используя параллельные стримы, возможно, вам потребуется синхронизировать доступ к общему ресурсу (например, к базе данных или общему файлу).
     Обычный стрим: Обрабатывает данные спокойно и последовательно.
     Параллельный стрим: Потоки пытаются одновременно получить доступ к одному и тому же ресурсу, что может привести к блокировкам и замедлениям).
     То есть если объем данных небольшой, эти накладные расходы могут превысить потенциальное время, сэкономленное за счет параллельной обработки.
   */
}
